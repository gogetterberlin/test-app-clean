"use client";
import React, { useState, useEffect, useRef, useMemo } from 'react';
import { readExcelFile, validateUrls } from '../utils/excel';

function saveScrapeResults(batchId: string, type: 'old' | 'new', results: any[]) {
  if (!batchId) return;
  localStorage.setItem(`scrape_${batchId}_${type}`, JSON.stringify(results));
}
function loadScrapeResults(batchId: string, type: 'old' | 'new') {
  if (!batchId) return [];
  try {
    return JSON.parse(localStorage.getItem(`scrape_${batchId}_${type}`) || '[]');
  } catch {
    return [];
  }
}

function generateHtaccess(redirects: any[]): string {
  return `# 301 Redirects for SEO Relaunch\n# Generated by SEO Redirect Generator\n\n` +
    redirects.map((r) => `Redirect 301 ${r.old_url} ${r.new_url}`).join("\n");
}
function generateNginx(redirects: any[]): string {
  return `# 301 Redirects for SEO Relaunch\n# Generated by SEO Redirect Generator\n\n` +
    redirects.map((r) => `rewrite ^${r.old_url}$ ${r.new_url} permanent;`).join("\n");
}
function generateCSV(redirects: any[]): string {
  return 'Old URL,New URL,Confidence,Method\n' +
    redirects.map((r) => `${r.old_url},${r.new_url},${Math.round((r.confidence_score || 0) * 100)}%,${r.match_type || 'ai'}`).join("\n");
}

export default function TestPipeline() {
  const [oldUrls, setOldUrls] = useState('https://example.com/old-1\nhttps://example.com/old-2');
  const [newUrls, setNewUrls] = useState('https://example.com/new-1\nhttps://example.com/new-2');
  const [log, setLog] = useState<string[]>([]);
  const [redirects, setRedirects] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [maxRows, setMaxRows] = useState<number>(2);
  const [analysis, setAnalysis] = useState<any[]>([]);
  const [analysisOld, setAnalysisOld] = useState<any[]>([]);
  const [analysisNew, setAnalysisNew] = useState<any[]>([]);
  const [showAnalysis, setShowAnalysis] = useState(false);
  const [oldUploadStatus, setOldUploadStatus] = useState<string>('');
  const [newUploadStatus, setNewUploadStatus] = useState<string>('');
  const [scrapeProgress, setScrapeProgress] = useState({ old: 0, new: 0 });
  const [scrapeTotal, setScrapeTotal] = useState({ old: 0, new: 0 });
  const [scrapeEta, setScrapeEta] = useState<number | null>(null);
  const [scraping, setScraping] = useState(false);
  const scrapeStartRef = useRef<number>(0);
  const [resultTab, setResultTab] = useState<'htaccess'|'nginx'|'csv'>('htaccess');
  const [showResults, setShowResults] = useState(false);
  const [resultError, setResultError] = useState<string | null>(null);

  const oldUrlList = oldUrls.split('\n').map(u => u.trim()).filter(Boolean);
  const newUrlList = newUrls.split('\n').map(u => u.trim()).filter(Boolean);

  const appendLog = (msg: string) => setLog(l => [...l, msg]);

  async function handleExcelUpload(e: React.ChangeEvent<HTMLInputElement>, type: 'old' | 'new') {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      if (type === 'old') setOldUploadStatus('Lade...');
      if (type === 'new') setNewUploadStatus('Lade...');
      const urls = validateUrls(await readExcelFile(file));
      if (type === 'old') {
        setOldUrls(urls.join('\n'));
        setOldUploadStatus('Erfolgreich geladen!');
      } else {
        setNewUrls(urls.join('\n'));
        setNewUploadStatus('Erfolgreich geladen!');
      }
    } catch {
      if (type === 'old') setOldUploadStatus('Fehler beim Laden!');
      if (type === 'new') setNewUploadStatus('Fehler beim Laden!');
    }
    setTimeout(() => {
      setOldUploadStatus('');
      setNewUploadStatus('');
    }, 2000);
  }

  async function runPipeline() {
    setLog([]);
    setRedirects([]);
    setAnalysis([]);
    setAnalysisOld([]);
    setAnalysisNew([]);
    setShowAnalysis(false);
    setScrapeProgress({ old: 0, new: 0 });
    setScrapeTotal({ old: oldUrlList.length, new: newUrlList.length });
    setScrapeEta(null);
    setScraping(true);
    scrapeStartRef.current = Date.now();
    setLoading(true);
    try {
      appendLog('1. Batch anlegen...');
      const batchRes = await fetch('/api/batch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          batchName: 'Test-Batch ' + new Date().toISOString(),
          oldUrls: oldUrlList,
          newUrls: newUrlList,
        })
      });
      const batchData = await batchRes.json();
      appendLog('Batch: ' + JSON.stringify(batchData));
      if (!batchData.batchId) throw new Error('Batch creation failed');
      const batchId = batchData.batchId;

      // Scraping-Queue für alt & neu
      async function scrapeQueue(urls: string[], type: 'old' | 'new', concurrency = 2) {
        let results = loadScrapeResults(batchId, type);
        let done = results.length;
        setScrapeProgress(p => ({ ...p, [type]: done }));
        setScrapeTotal(t => ({ ...t, [type]: urls.length }));
        const queue = urls.map((url, i) => ({ url, i }));
        let idx = done;
        let running = 0;
        let etaInterval: any = null;
        function updateEta() {
          const elapsed = (Date.now() - scrapeStartRef.current) / 1000;
          const left = urls.length - done;
          if (done > 0 && left > 0) {
            const avg = elapsed / done;
            setScrapeEta(Math.round(avg * left));
          } else {
            setScrapeEta(null);
          }
        }
        etaInterval = setInterval(updateEta, 1000);
        return new Promise<any[]>(resolve => {
          async function next() {
            if (done >= urls.length) {
              clearInterval(etaInterval);
              resolve(results);
              return;
            }
            while (running < concurrency && idx < urls.length) {
              const { url, i } = queue[idx++];
              running++;
              (async () => {
                const res = await fetch('/api/scrape', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ url })
                });
                const data = await res.json();
                results[i] = data;
                saveScrapeResults(batchId, type, results);
                done++;
                setScrapeProgress(p => ({ ...p, [type]: done }));
                setAnalysisOld(type === 'old' ? [...results] : a => a);
                setAnalysisNew(type === 'new' ? [...results] : a => a);
                updateEta();
                running--;
                setTimeout(next, 1200); // 1.2s Pause
              })();
            }
          }
          next();
        });
      }

      appendLog('2. Scraping...');
      // Scrape alt & neu parallel (jeweils mit concurrency=2)
      const [oldResults, newResults] = await Promise.all([
        scrapeQueue(oldUrlList, 'old', 2),
        scrapeQueue(newUrlList, 'new', 2),
      ]);
      setAnalysisOld(oldResults);
      setAnalysisNew(newResults);
      setScraping(false);
      setShowAnalysis(true);
      appendLog('Scrape abgeschlossen.');

      appendLog('3. Matching...');
      const matchRes = await fetch('/api/match', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ batchId })
      });
      const matchData = await matchRes.json();
      appendLog('Match: ' + JSON.stringify(matchData));
      if (!matchData.success) throw new Error('Matching failed');

      appendLog('4. Redirects abfragen...');
      const redirectsRes = await fetch(`/api/redirects?batchId=${batchId}`);
      const redirectsData = await redirectsRes.json();
      setRedirects(redirectsData.data || []);
      appendLog('Redirects: ' + JSON.stringify(redirectsData.data || []));
    } catch (e: any) {
      appendLog('Fehler: ' + e.message);
    } finally {
      setLoading(false);
      setScraping(false);
      setScrapeEta(null);
    }
  }

  // Nach Matching: Redirects laden und Results anzeigen
  useEffect(() => {
    if (!showAnalysis || !log.some(l => l.includes('Match:'))) return;
    (async () => {
      const lastBatchId = log.find(l => l.includes('Batch:'))?.match(/"batchId":"([^"]+)"/i)?.[1];
      if (!lastBatchId) {
        setResultError('Fehler: BatchId konnte nicht ermittelt werden. Bitte Pipeline erneut starten.');
        setShowResults(false);
        return;
      }
      try {
        const res = await fetch(`/api/redirects?batchId=${lastBatchId}`);
        const data = await res.json();
        if (!data.data || !Array.isArray(data.data) || data.data.length === 0) {
          setResultError('Keine Redirects gefunden. Bitte Matching erneut durchführen.');
          setShowResults(false);
          return;
        }
        setRedirects(data.data);
        setShowResults(true);
        setResultError(null);
      } catch (e) {
        setResultError('Fehler beim Laden der Redirects.');
        setShowResults(false);
      }
    })();
  }, [showAnalysis, log]);

  // Stats für Ergebnis-Screen
  const stats = useMemo(() => {
    const total = redirects.length;
    const ai = redirects.filter(r => r.match_type === 'ai').length;
    const confidence = redirects.length ? Math.round(redirects.reduce((acc, r) => acc + (r.confidence_score || 0), 0) / redirects.length * 100) : 0;
    return { total, ai, confidence };
  }, [redirects]);

  // Export-Strings
  const exports = useMemo(() => ({
    htaccess: generateHtaccess(redirects),
    nginx: generateNginx(redirects),
    csv: generateCSV(redirects),
  }), [redirects]);

  return (
    <div className="min-h-screen w-full bg-gradient-to-br from-white via-slate-50 to-slate-100 text-gray-900 flex flex-col items-center px-0 md:px-0">
      <header className="w-full py-10 px-0 bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500 text-white shadow-lg mb-12">
        <div className="flex items-center justify-between w-full max-w-7xl mx-auto px-6 md:px-12">
          <div className="text-3xl md:text-4xl font-extrabold tracking-tight">SEO 301 Redirect Tool</div>
          <div className="text-xs opacity-80">Inspired by Vercel</div>
        </div>
      </header>
      <main className="w-full max-w-5xl flex-1 flex flex-col gap-12 items-center justify-start px-2 md:px-8">
        <h2 className="text-4xl md:text-5xl font-extrabold tracking-tight text-center mb-8 mt-0">Backend-Pipeline Test</h2>
        <section className="w-full flex flex-wrap gap-8 mb-8">
          <div className="flex-1 min-w-[320px] bg-white rounded-3xl shadow-xl border border-indigo-100 p-8 flex flex-col gap-4">
            <label className="font-bold text-lg text-indigo-700">Alte URLs (eine pro Zeile):</label>
            <input type="file" accept=".xlsx,.xls,.csv" className="mb-2 mt-1 ml-0" onChange={e => handleExcelUpload(e, 'old')} />
            {oldUploadStatus && <span className={oldUploadStatus.includes('Fehler') ? 'text-red-500' : 'text-emerald-500'}>{oldUploadStatus}</span>}
            <textarea rows={10} className="w-full font-mono text-base border-0 border-b-2 border-indigo-400 rounded-none p-4 mb-2 bg-slate-50 resize-vertical min-h-[120px] max-h-[300px]" value={oldUrls} onChange={e => setOldUrls(e.target.value)} />
            <div className="text-indigo-500 font-semibold mb-2">{oldUrlList.length} URLs importiert</div>
            <div className="bg-slate-100 p-2 max-h-32 overflow-y-auto font-mono text-sm w-full border-l-4 border-indigo-400 rounded-md">
              {oldUrlList.map((url, i) => <div key={i} className="truncate">{url}</div>)}
            </div>
          </div>
          <div className="flex-1 min-w-[320px] bg-white rounded-3xl shadow-xl border border-pink-100 p-8 flex flex-col gap-4">
            <label className="font-bold text-lg text-pink-700">Neue URLs (eine pro Zeile):</label>
            <input type="file" accept=".xlsx,.xls,.csv" className="mb-2 mt-1 ml-0" onChange={e => handleExcelUpload(e, 'new')} />
            {newUploadStatus && <span className={newUploadStatus.includes('Fehler') ? 'text-red-500' : 'text-emerald-500'}>{newUploadStatus}</span>}
            <textarea rows={10} className="w-full font-mono text-base border-0 border-b-2 border-pink-400 rounded-none p-4 mb-2 bg-slate-50 resize-vertical min-h-[120px] max-h-[300px]" value={newUrls} onChange={e => setNewUrls(e.target.value)} />
            <div className="text-pink-500 font-semibold mb-2">{newUrlList.length} URLs importiert</div>
            <div className="bg-slate-100 p-2 max-h-32 overflow-y-auto font-mono text-sm w-full border-l-4 border-pink-400 rounded-md">
              {newUrlList.map((url, i) => <div key={i} className="truncate">{url}</div>)}
            </div>
          </div>
        </section>
        <section className="w-full flex items-center justify-center gap-4 mb-8">
          <label className="font-bold text-lg mr-2">Analysiere die ersten</label>
          <input type="number" min={1} max={oldUrlList.length} value={maxRows} onChange={e => setMaxRows(Number(e.target.value))} className="w-20 text-lg rounded-md p-2 border-2 border-indigo-400" />
          <span className="text-gray-500 text-lg">Seiten</span>
        </section>
        <section className="w-full flex items-center justify-center mb-12">
          <button onClick={runPipeline} disabled={loading || scraping} className="px-16 py-5 text-2xl rounded-2xl bg-gradient-to-r from-indigo-500 to-pink-500 text-white font-extrabold shadow-xl hover:scale-105 hover:shadow-2xl transition disabled:opacity-40 disabled:scale-100">
            {loading || scraping ? 'Bitte warten...' : 'Pipeline testen'}
          </button>
        </section>
        <section className="w-full font-mono text-base bg-slate-100 rounded-2xl p-6 mb-8 min-h-[60px] max-h-[180px] overflow-y-auto shadow-inner border border-slate-200">
          {log.map((l, i) => <div key={i}>{l}</div>)}
        </section>
        {/* Progress & Analyse */}
        {(scraping || scrapeProgress.old > 0 || scrapeProgress.new > 0) && (
          <section className="w-full flex flex-col items-center mb-12">
            <div className="w-full max-w-xl bg-slate-100 rounded-2xl overflow-hidden mb-6 border-2 border-indigo-200 shadow">
              <div className="h-8 bg-gradient-to-r from-indigo-500 to-pink-500 flex items-center justify-center text-white font-bold text-lg transition-all duration-500" style={{ width: `${Math.round(((scrapeProgress.old + scrapeProgress.new) / (scrapeTotal.old + scrapeTotal.new || 1)) * 100)}%` }}>
                {Math.round(((scrapeProgress.old + scrapeProgress.new) / (scrapeTotal.old + scrapeTotal.new || 1)) * 100)}%
              </div>
            </div>
            <div className="font-mono text-lg text-indigo-500 mb-4 font-bold">Scraping: <span className="text-black">{scrapeProgress.old + scrapeProgress.new}</span> / {scrapeTotal.old + scrapeTotal.new} Seiten{scrapeEta !== null ? <span className="text-gray-400 font-normal"> (ca. {scrapeEta}s)</span> : ''}</div>
            <div className="w-full flex flex-wrap gap-8 justify-center mt-4">
              <div className="flex-1 min-w-[320px] max-w-[600px]">
                <h3 className="text-xl font-bold text-indigo-700 mb-2 text-center">Analysierte alte URLs</h3>
                <div className="bg-white rounded-2xl p-6 min-h-[100px] shadow border border-indigo-100 max-h-[340px] overflow-y-auto flex flex-col gap-4">
                  {analysisOld.length === 0 ? <div className="text-red-500 font-semibold">Keine alten URLs analysiert.</div> : analysisOld.map((u, i) => (
                    <div key={u.id || i} className={`border-b border-slate-200 pb-2 mb-2 transition ${u.error ? 'bg-red-50' : ''}`}>
                      <div className="font-bold text-indigo-700 text-base mb-1">{u.url}</div>
                      <div className="flex flex-wrap gap-4 text-base">
                        <span><b>Status:</b> {u.status_code ?? u.status}</span>
                        <span><b>Titel:</b> {u.title}</span>
                        <span><b>Meta:</b> {u.meta_description}</span>
                        <span><b>H1:</b> {u.h1_heading}</span>
                      </div>
                      <div className="text-gray-500 text-sm mt-1 whitespace-pre-line"><b>Main:</b> {u.main_content?.slice(0, 200) || ''}{u.main_content && u.main_content.length > 200 ? '…' : ''}</div>
                      {u.error && <div className="text-red-500 font-bold text-sm mt-2">Fehler: {u.error}</div>}
                    </div>
                  ))}
                </div>
              </div>
              <div className="flex-1 min-w-[320px] max-w-[600px]">
                <h3 className="text-xl font-bold text-pink-700 mb-2 text-center">Analysierte neue URLs</h3>
                <div className="bg-white rounded-2xl p-6 min-h-[100px] shadow border border-pink-100 max-h-[340px] overflow-y-auto flex flex-col gap-4">
                  {analysisNew.length === 0 ? <div className="text-red-500 font-semibold">Keine neuen URLs analysiert.</div> : analysisNew.map((u, i) => (
                    <div key={u.id || i} className={`border-b border-slate-200 pb-2 mb-2 transition ${u.error ? 'bg-red-50' : ''}`}>
                      <div className="font-bold text-pink-700 text-base mb-1">{u.url}</div>
                      <div className="flex flex-wrap gap-4 text-base">
                        <span><b>Status:</b> {u.status_code ?? u.status}</span>
                        <span><b>Titel:</b> {u.title}</span>
                        <span><b>Meta:</b> {u.meta_description}</span>
                        <span><b>H1:</b> {u.h1_heading}</span>
                      </div>
                      <div className="text-gray-500 text-sm mt-1 whitespace-pre-line"><b>Main:</b> {u.main_content?.slice(0, 200) || ''}{u.main_content && u.main_content.length > 200 ? '…' : ''}</div>
                      {u.error && <div className="text-red-500 font-bold text-sm mt-2">Fehler: {u.error}</div>}
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </section>
        )}
        {/* Ergebnis-Screen */}
        {showResults && !resultError && (
          <section className="w-full flex flex-col items-center gap-12 mt-12">
            {/* Stats */}
            <div className="flex gap-12 mb-8 flex-wrap justify-center">
              <div className="bg-white rounded-2xl shadow-xl border-2 border-indigo-100 p-8 min-w-[180px] text-center">
                <div className="text-3xl font-extrabold text-indigo-500 mb-2">{stats.total}</div>
                <div className="text-lg text-gray-500 font-semibold">Redirects</div>
              </div>
              <div className="bg-white rounded-2xl shadow-xl border-2 border-pink-100 p-8 min-w-[180px] text-center">
                <div className="text-3xl font-extrabold text-pink-500 mb-2">{stats.ai}</div>
                <div className="text-lg text-gray-500 font-semibold">AI-Matches</div>
              </div>
              <div className="bg-white rounded-2xl shadow-xl border-2 border-emerald-100 p-8 min-w-[180px] text-center">
                <div className="text-3xl font-extrabold text-emerald-500 mb-2">{stats.confidence}%</div>
                <div className="text-lg text-gray-500 font-semibold">Ø Confidence</div>
              </div>
            </div>
            {/* Export-Box */}
            <div className="bg-white rounded-3xl shadow-2xl border-2 border-indigo-100 p-10 w-full max-w-2xl mb-8 flex flex-col items-center gap-6">
              <div className="flex gap-4 mb-4 items-center justify-center w-full">
                {(['htaccess', 'nginx', 'csv'] as const).map(tab => (
                  <button key={tab} onClick={() => setResultTab(tab)} className={`px-8 py-3 rounded-2xl text-lg font-bold transition-all duration-200 border-2 shadow-sm ${resultTab === tab ? 'bg-gradient-to-r from-indigo-500 to-pink-500 text-white border-indigo-400 scale-105 shadow-xl' : 'bg-gray-50 text-gray-400 border-gray-200 hover:bg-indigo-50 hover:text-indigo-600'}`}>
                    {tab === 'htaccess' ? '.htaccess' : tab === 'nginx' ? 'Nginx' : 'CSV/Excel'}
                  </button>
                ))}
              </div>
              <pre className="bg-gray-50 rounded-xl p-6 text-base font-mono overflow-x-auto border border-gray-100 transition-all duration-150 w-full min-h-[120px] max-h-[220px] text-gray-700 shadow-inner">{exports[resultTab]}</pre>
              <div className="flex gap-4 w-full justify-end">
                <button onClick={() => { navigator.clipboard.writeText(exports[resultTab]); }} className="px-6 py-3 rounded-2xl bg-gradient-to-r from-emerald-400 to-indigo-400 text-white text-lg font-bold shadow-xl hover:scale-105 hover:shadow-2xl transition">Copy</button>
                <a href={`data:text/plain;charset=utf-8,${encodeURIComponent(exports[resultTab])}`} download={`redirects.${resultTab === 'csv' ? 'csv' : 'txt'}`} className="px-6 py-3 rounded-2xl bg-gradient-to-r from-indigo-500 to-pink-500 text-white text-lg font-bold shadow-xl hover:scale-105 hover:shadow-2xl transition" >Download</a>
              </div>
            </div>
            {/* Detailansicht */}
            <div className="w-full max-w-4xl flex flex-col gap-8">
              {redirects.map((r, i) => {
                const oldData = analysisOld.find(u => u.url === r.old_url?.url || u.url === r.old_url);
                const newData = analysisNew.find(u => u.url === r.new_url?.url || u.url === r.new_url);
                return (
                  <div key={i} className="flex items-center gap-0 w-full">
                    {/* Alte URL Box */}
                    <div className="flex-1 bg-slate-100 rounded-2xl p-6 min-w-[220px] shadow border border-indigo-100 mr-0">
                      <div className="font-bold text-indigo-700 text-base mb-1">{oldData?.url || r.old_url?.url || r.old_url}</div>
                      <div className="text-base text-gray-500 mb-1"><b>Titel:</b> {oldData?.title}</div>
                      <div className="text-base text-gray-500 mb-1"><b>Meta:</b> {oldData?.meta_description}</div>
                      <div className="text-base text-gray-500 mb-1"><b>H1:</b> {oldData?.h1_heading}</div>
                      <div className="text-sm text-gray-400 mb-1"><b>Main:</b> {oldData?.main_content?.slice(0, 120) || ''}{oldData?.main_content && oldData.main_content.length > 120 ? '…' : ''}</div>
                    </div>
                    {/* Pfeil */}
                    <div className="w-16 flex items-center justify-center h-full">
                      <div className="w-10 h-1 bg-gradient-to-r from-indigo-400 to-pink-400 relative">
                        <div className="absolute right-[-10px] top-[-7px] w-0 h-0 border-t-8 border-b-8 border-l-8 border-t-transparent border-b-transparent border-l-pink-400" />
                      </div>
                    </div>
                    {/* Neue URL Box */}
                    <div className="flex-1 bg-white rounded-2xl p-6 min-w-[220px] shadow border border-pink-100 ml-0">
                      <div className="font-bold text-pink-700 text-base mb-1">{newData?.url || r.new_url?.url || r.new_url}</div>
                      <div className="text-base text-gray-500 mb-1"><b>Titel:</b> {newData?.title}</div>
                      <div className="text-base text-gray-500 mb-1"><b>Meta:</b> {newData?.meta_description}</div>
                      <div className="text-base text-gray-500 mb-1"><b>H1:</b> {newData?.h1_heading}</div>
                      <div className="text-sm text-gray-400 mb-1"><b>Main:</b> {newData?.main_content?.slice(0, 120) || ''}{newData?.main_content && newData.main_content.length > 120 ? '…' : ''}</div>
                    </div>
                  </div>
                );
              })}
            </div>
          </section>
        )}
        {resultError && (
          <section className="w-full flex flex-col items-center gap-12 mt-12">
            <div className="bg-red-50 text-red-700 border-2 border-red-200 rounded-2xl p-10 text-2xl font-bold mt-12">
              {resultError}
            </div>
          </section>
        )}
      </main>
    </div>
  );
} 